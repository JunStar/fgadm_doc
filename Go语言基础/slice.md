# 使用已有数组创建切片
```
package main

import "fmt"

func main() {

	a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	fmt.Printf("数组a的内存地址：%p\n", &a)
	fmt.Println("a的值：", a)
	s1 := a[0:5]
	s1[0] = 11
	fmt.Printf("s1的内存地址：%p\n", s1) //s1不要使用&符号，可以加上看下打印结果
	fmt.Println("s1的值：", s1)
	fmt.Println("a的值：", a)
	s2 := a[5:6]
	fmt.Printf("s2的内存地址：%p\n", s2) //s2不要使用&符号
	fmt.Println("s2的值：", s2)
}

#运行结果
数组a的内存地址：0xc000014190
a的值： [1 2 3 4 5 6 7 8 9 10]
s1的内存地址：0xc000014190
s1的值： [11 2 3 4 5]
a的值： [11 2 3 4 5 6 7 8 9 10]
s2的内存地址：0xc0000141b8
s2的值： [6]
```

注意，在打印切片的内存地址时，前面不要加上指针符号&，如果加上了&，切片和数组的内存地址就不会一样了，

思考：切片作为一个引用类型，他本身开辟了一块内存，进行存储，而存储的值是底层数组的内存地址，当使用`fmt.Printf("s1的内存地址：%p\n", s1)`打印s1的内存时，直接打印的是s1在内存中存储的值，且这个值就是底层数组索引为0的内存地址。而当使用&s1打印内存地址时，打印的是s1在内存中存储的内存地址